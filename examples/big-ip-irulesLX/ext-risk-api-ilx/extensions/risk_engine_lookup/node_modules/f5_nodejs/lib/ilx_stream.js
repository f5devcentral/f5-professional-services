/*jshint node:true*/
'use strict';

var assert = require('assert');
var net = require('net');
var util = require('util');
var ILXStreamWrap = null;
var ILXTransaction = require('./ilx_transaction.js');

/**
 * An ILXStream is a wrapper around a Node.js net.Socket object. All data that goes through the
 * socket goes through the Big IP TMM and not the Linux TCP stack.
 *
 * @constructor
 * @param {object} options    - Options that are passed to the Node.js socket class
 * @param {object} streamWrap - C++ implementation wrapper
 */
function ILXStream(options)
{
    options = options || {};
    if (options.handle === undefined) {
        // user created
        if (ILXStreamWrap === null) {
            ILXStreamWrap = process.binding('ILXStreamWrap').ILXStreamWrap;
        }
        options.handle = new ILXStreamWrap();
        net.Socket.call(this, options); // sets this._handle.owner

        // net.socket properties we need to set
        this.writable = false;
        this.connecting = false;
        this.f5 = {};
    }
    else {
        // called from ILXFlow
        assert(options.f5.flow);
        net.Socket.call(this, options); // sets this._handle.owner

        // net.socket properties we need to set
        this.writable = true; // part of a flow, can be read/written now
        this.connecting = false;
        this.f5 = options.f5;
    }

    // callbacks that are invoked from the c++ implementation
    this._handle.onIlxRequestStart = ilxRequestStartCb;
    this._handle.onIlxRequestDone = ilxRequestDoneCb;
    this._handle.onIlxResponseStart = ilxResponseStartCb;
    this._handle.onIlxResponseDone = ilxResponseDoneCb;
    this._handle.onIlxServerConnected = ilxConnectedCb;
    this._handle.onIlxError = ilxErrorCb;
}
util.inherits(ILXStream, net.Socket);

/**
 * Establish a TCP connection to the specified host or Virtual Server. A host or virtualServer
 * must be specified, but not both.
 *
 * @param {object} options
 * @param {string} options.host - The system will attempt to connect to the IP address. The
 *   address may contain a route domain qualifier, example: 10.10.0.1%5.
 * @param {integer} options.port - IP port
 * @param {string} options.virtualServer - The system will attempt to connect to the virtual
 *   server. If specified this must be a fully qualified name, example: /Common/myVip.
 * @param {string} options.virtualProtocolStack - To establish a connection the system uses
 *   the server side protocol stack of a virtual server associated with the current ILX Plugin.
 *   This setting allows the developer to select which virtual server will be used to build
 *   the protocol stack. The specified virtual server must be associated with the current ILX
 *   plugin via an ILX Profile. If a virtualProtocolStack is not specified one will be selected.
 *   Note that this option is independent of the host and virtualServer options.
 * @param {boolean} options.disableSsl - If an SSL profile is present on the serverside of
 *   the virtual server this setting can be used to disable SSL for a plugin initiated connection.
 */
ILXStream.prototype.connect = function(options)
{
    this._handle.connect(options.host, options.port, options.virtualServer,
        options.virtualProtocolStack, options.disableSsl, "TCP");

    // used by net.socket
    this.connecting = true;
    this.writable = true;
};

ILXStream.prototype.__defineGetter__('localRouteDomain', function()
{
    return this._getsockname().routeDomain;
});

ILXStream.prototype.__defineGetter__('remoteRouteDomain', function()
{
    return this._getpeername().routeDomain;
});

ILXStream.prototype.__defineGetter__('localFamily', function()
{
    return this._getsockname().family;
});

ILXStream.prototype.__defineGetter__('haUnit', function()
{
    return this._getpeername().haUnit;
});

ILXStream.prototype.allow = function()
{
    if (this._handle) {
        return this._handle.allow();
    }
    return 1;
};

/**
 * The connect event is emitted when the connection to the server is established.
 *
 * @fires ILXStream#connect
 */
ILXStream.prototype._connected = function()
{
    this.connecting = false; // net.socket uses this
    this.emit('connect');
};
/**
 * Emit the connect event
 * @event ILXStream#connect
 *
 */

/**
 * This is called when the TMM successfully establishes a plugin initiated connection.
 *
 * @param {object} handle - C++ stream implementation
 */
function ilxConnectedCb(handle)
{
    var self = handle.owner;
    self._connected();
}

/**
 * The error event is emitted when a stream error is detected.
 * @fires ILXStream#error
 * @param {string} errorText - Description of the error
 */
function ilxErrorCb(handle, errorText)
{
    var self = handle.owner;
    self.connecting = false; // net.socket uses this
    self.emit('error', errorText);
}
/**
 * Emit the error event
 * @event ILXStream#error
 */

/**
 * Set the trace level for the stream.
 *
 * @param {integer} level - the higher the value the more tracing information will be generated
 */
ILXStream.prototype.setTraceLevel = function(level)
{
    this._traceLevel = level;
    if (this._handle) {
        this._handle.setTraceLevel(level);
    }
};

/**
 * Returns the trace level for the stream.
 */
ILXStream.prototype.traceLevel = function()
{
    return this._traceLevel;
};

/**
 * The requestStart event is emitted when pre-parsed client HTTP request headers are
 * available. This event is only emitted if there is an HTTP profile on the virtual server.
 *
 * @fires ILXStream#requestStart
 */
function ilxRequestStartCb(handle, params)
{
    var self = handle.owner;
    self._curRequest = new ILXTransaction(self, params, false, undefined);
    self.emit('requestStart', self._curRequest);
}
/**
 * Emit the requestStart event
 * @event ILXStream#requestStart
 * @param {object}      request - Request object
 * @property {string}   request.params.uri - Request URI
 * @property {string}   request.params.method - Request method
 * @property {string}   request.params.version - Protocol version
 * @property {string}   request.params.path - Path portion of the URI, may be undefined
 * @property {string}   request.params.query - Query portion of the URI, may be undefined
 * @property {object}   headers.params.<header name> - The set of headers in the request
 */

/**
 * The requestComplete event is emitted after the body of a request has been received.
 * This event is only emitted if there is an HTTP profile on the virtual server.
 *
 * @fires ILXStream#requestComplete
 */
function ilxRequestDoneCb(handle, bodyComplete)
{
    var self = handle.owner;
    self._curRequest.params.truncated = !bodyComplete;
    self.emit('requestComplete', self._curRequest);
    self._curRequest = undefined;
}
/**
 * Emit the requestComplete event
 *
 * @event ILXStream#requestComplete
 * @param {object}      request - Original request object.
 * @property {string}   request.params - Original request parameters
 * @property {string}   request.params.truncated - Indicates if the request body was truncated
 */

/**
 * The responseStart event is emitted when pre-parsed HTTP response header values are available.
 * This event is only emitted if there is an HTTP profile associated with the virtual server.
 *
 * @fires ILXFlow#responseStart
 */
function ilxResponseStartCb(handle, clientStream, params)
{
    var self = handle.owner;
    self._curResponse = new ILXTransaction(self, params, true, clientStream.owner);
    self.emit('responseStart', self._curResponse);
}
/**
 * Emit the responseStart event
 *
 * @event ILXFlow#responseStart
 * @param {object}    response - Response object
 * @property {string} response.params.status - Response status
 * @property {string} response.params.version - Protocol version
 * @property {string} response.params.headers.<header name> - The set of headers in the server
 *   response.
 * @property {boolean} response.params.closeOnComplete - The default behavior is for the ILX
 *   framework to call flow.client.end() once the Plugin calls ILXTransaction.complete()
 *   for a response transaction. This is primarily so that configurations with a one-connect
 *   profile work properly with clients that specify a keep-alive connection. This can be
 *   overridden by setting response.params.closeOnComplete to false before calling
 *   response.complete().
 */

/**
 * The responseDone event is emitted after the body of a response has been received.
 * This event is only emitted if there is an HTTP profile associated with the virtual server.
 *
 * @fires ILXFlow#responseComplete
 */
function ilxResponseDoneCb(handle, bodyComplete)
{
    var self = handle.owner;
    self._curResponse.params.truncated = !bodyComplete;
    self.emit('responseComplete', self._curResponse);
    self._curResponse = undefined;
}
/**
 * Emit the responseDone event
 *
 * @event ILXFlow#responseComplete
 * @param {object}      response - Original request object.
 * @property {string}   response.params - Original request parameters
 * @property {string}   response.params.truncated - Indicates if the request body was truncated
 */

/**
 * Returns the ID of the TMM that is handling the stream.
 */
ILXStream.prototype.tmmId = function()
{
    if (!this._handle) {
        throw new Error("Stream is not active");
    }
    return this._handle.tmmId();
};

module.exports = ILXStream;
