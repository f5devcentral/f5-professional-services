/*jshint node:true*/
'use strict';

var events = require('events');
var util = require('util');
var ILXStream = require('./ilx_stream.js');
var _ilxFlowId = 0;

/**
 * An ILXFlow is created by the ILXPlugin class when a client connects to a virtual server.
 * The flow represents an end to end connection from the client, through a BigIP, to the server.
 * There are client side (ILXFlow.client.stream) and server side streams (ILXFlow.server.stream)
 * available.
 *
 * @constructor
 * @param {object} flowWrap - C++ implementation wrapper
 * @param {object} clientStreamWrap - C++ implementation wrapper
 * @param {object} serverStreamWrap - C++ implementation wrapper
 * @param {boolean} isTcp - Indicates whether the flow is TCP based. This is the only suported
 * option.
 *
 */
function ILXFlow(flowWrap, clientStreamWrap, serverStreamWrap, isTcp)
{
    events.EventEmitter.call(this);

    // link both ways, ILXFlow knows the C++ ILXFlowWrap object, and the wrapper knows the
    // ILXFlow object
    this._handle = flowWrap;
    this._handle.owner = this;
    this._id = ++_ilxFlowId;

    this.virtual = this._handle.getVsInfo();

    if (isTcp === true) {
        this.client = new ILXStream( { handle: clientStreamWrap, f5 : { flow: this } } );
        this.server = new ILXStream( { handle: serverStreamWrap, f5 : { flow: this } } );
    }

    // load balancing and server connection info is available after the
    // connect event has occured
    this._lbInfo = false;

    // callbacks that are invoked from the c++ implementation
    this._handle.onIlxServerConnected = ilxServerConnectedCb;
    this._handle.onIlxClose = ilxCloseCb;
    this._handle.onIlxError = ilxFlowErrorCb;

    this._active = true;

    this._traceLevel = 0;
}
util.inherits(ILXFlow, events.EventEmitter);

/**
 * When the BigIP connects to the server load balancing information is made available and the
 * server emits a connect event.
 *
 * @param {object} handle - C++ flow implementation
 */
function ilxServerConnectedCb(handle)
{
    var self = handle.owner;
    self.server._connected();
}

/**
 * When the BigIP connects to the server load balancing information is available via
 * the object ILXFlow.lb.
 *
 * @property {string} ILXFlow.lb.virtualServer - If the remote server is a Virtual Server
 * @property {string} ILXFlow.lb.pool - LTM pool name
 * @property {object} ILXFlow.lb.remote - Remote server information
 * @property {string} ILXFlow.lb.remote.address - Remote server address
 * @property {integer} ILXFlow.lb.remote.port - Remote server port
 * @property {integer} ILXFlow.lb.routeDomain - Remote server route domain
 * @property {integer} ILXFlow.lb.vlan - Numeric VLAN ID used for the connection to the server
 * @property {string} ILXFlow.lb.nexthop - MAC address, undefined if the nexthop is all zeros
 * @property {string} ILXFlow.lb.snatpool - SNAT pool name, if SNAT is enabled
 * @property {} ILXFlow.lb.local.address - Local address, if SNAT is enabled
 * @property {} ILXFlow.lb.local.port - Local port, if SNAT is enabled
 * @property {} ILXFlow.lb.local.routeDomain - Local route domain, if SNAT is enabled
 *
 */
ILXFlow.prototype.__defineGetter__('lb', function() {
    if ((this._active !== true) || !this._handle) {
        throw new Error("Flow is not active");
    }
    if (!this._lbInfo) {
        var out = {local: {}, remote: {}};
        var err = this._handle.getLbSelection(out);
        if (err) {
            return out;
        }
        this._lbInfo = out;
    }
    return this._lbInfo;
});

/**
 * The error event is emitted when there is an error encountered on the flow.
 *
 * @fires ILXFlow#error
 */
function ilxFlowErrorCb(handle, errorText)
{
    var self = handle.owner;
    self.emit("error", errorText);
}
/**
 * Emit the error event
 *
 * @event ILXFlow#error
 * @param {string} msg - error text
 */

/**
 * The close event is emitted when both client and server connections of an ILXFlow have been
 * closed.
 *
 * @fires ILXFlow#close
 */
function ilxCloseCb(handle)
{
    var self = handle.owner;
    self._active = false;
    self.emit("close");
}
/**
 * Emit the close event
 *
 * @event ILXFlow#close
 */

/**
 * Detach the flow, including both client and server streams from the tmm. Data will continue to
 * flow to and from the client and server but the plugin is no longer in the loop. The plugin
 * receives no further data events for this stream. This will increase performance of applications
 * that inspect a relatively small amount of traffic at the beginning of a connection, while
 * allowing the remainder of the connection to be processed entirely by the BigIP tmm.
 * Note that for Node.js to properly shutdown the client and server streams the close event
 * will be emitted. Any actions performed on a stream that has been detached will result in an
 * exception.
*/
ILXFlow.prototype.detach = function()
{
    if ((this._active === true) && this._handle) {
        return this._handle.detach();
    }
    return 1;
};

/**
 * Specify that the system connect to a specific virtual, pool or server. See also ILXLbOptions.
 * Note that for a load balancing selection to be made the plugin must enable the plugin
 * option ILXPluginOptions.handleClientOpen and not write any data to the server stream
 * ILXFlow.server until after the load balancing selection has been made.
 *
 * @param {object} lbOptions - ILXLbOptions
*/
ILXFlow.prototype.lbSelect = function(lbOptions)
{
    if ((this._active === true) && this._handle) {
        return this._handle.lbSelect(lbOptions);
    }
    return 0;
};

/**
 * Returns the traffic group HA unit associated with the flow.
 */
ILXFlow.prototype.__defineGetter__('haUnit', function()
{
    if (this._active !== true) {
        throw new Error("Flow is not active");
    }
    if (this.client) {
        return this.client.haUnit;
    }
    else if (this.server) {
        return this.server.haUnit;
    }
    throw new Error("Flow is not active");
});

/**
 * Calls end() on the client and server sockets. Similar to net.Socket.end() this function
 * has no return value.
 */
ILXFlow.prototype.end = function()
{
    if (this._active === true) {
        if (this.client) {
            this.client.end();
        }
        if (this.server) {
            this.server.end();
        }
    }
};

/**
 * Destroys the client and server sockets. Similar to net.Socket.destroy() this function
 * has no return value.
 */
ILXFlow.prototype.destroy = function()
{
    if ((this._active === true) && this._handle) {
        if (this.client) {
            this.client.destroy();
        }
        if (this.server) {
            this.server.destroy();
        }
        this._handle.destroy();
    }
};

/**
 * Causes a TCP reset to go to both the client (ILXFlow.client) and server (ILXFlow.server)
 * associated with a flow. The return value indicates if the flow was successfully aborted.
 *
 * @param {string} reason - An optional reason for aborting the flow. If a reason is provided and
 * the DB variable tm.rstcause.log is enabled the reason will be logged to /var/log/ltm.
 */
ILXFlow.prototype.reset = function(reason)
{
    if ((this._active === true) && this._handle) {
        return this._handle.reset(reason);
    }
    return false;
};

/**
 * Set the trace level for the flow and optionally the streams associated with the flow.
 *
 * @param {integer} level - the higher the value the more tracing information will be generated
 * @param {boolean} streams - If set to false the trace level for the streams associated with the
 *   the flow will not be set. The default is to set the stream trace level to be the same as the
 *   flow.
 */
ILXFlow.prototype.setTraceLevel = function(level, streams)
{
    if ((this._active === true) && this._handle) {
        this._handle.setTraceLevel(level);
        if ((streams === undefined) || (streams === true)) {
            if (this.client) {
                this.client.setTraceLevel(level);
            }
            if (this.server) {
                this.server.setTraceLevel(level);
            }
        }
    }
};

/**
 * Returns the flow trace level.
 */
ILXFlow.prototype.traceLevel = function()
{
    return this._traceLevel;
};

/**
 * Returns the ID of the TMM that is handling the flow.
 */
ILXFlow.prototype.tmmId = function()
{
    if (!this._handle) {
        throw new Error("Flow is not active");
    }
    return this._handle.tmmId();
};

/**
 * Returns numeric ID of the flow.
 */
ILXFlow.prototype.__defineGetter__('id', function() {
    return this._id;
});

module.exports = ILXFlow;
